# Knowledge Graph Access Commands

This document describes the knowledge graph CLI commands for browsing and searching graphs in Claude Code.

## Overview

The knowledge access commands provide a convenient way to explore and query the knowledge graphs generated by triad agents. These graphs contain entities, decisions, findings, and relationships discovered during triad execution.

## Architecture

### Components

1. **GraphLoader** (`src/triads/km/graph_access.py`)
   - Lazy-loading graph manager with per-session caching
   - Secure file path validation
   - NetworkX JSON format parsing

2. **GraphSearcher** (`src/triads/km/graph_access.py`)
   - Case-insensitive substring search
   - Filtering by triad, type, and confidence
   - Relevance-based result ranking

3. **GraphFormatter** (`src/triads/km/graph_access.py`)
   - Markdown output formatting
   - Consistent table layouts
   - Readable relationship displays

### Files

- **Module**: `src/triads/km/graph_access.py` (1000+ lines)
- **Commands**: `.claude/commands/knowledge-*.md` (4 files)
- **Graphs**: `.claude/graphs/*_graph.json` (NetworkX JSON format)

## Commands

### /knowledge-status

**Purpose**: View graph statistics and health metrics

**Usage**:
```python
from triads.km.graph_access import get_status

# All graphs
print(get_status())

# Single triad
print(get_status('design'))
```

**Output**:
- Summary table with node/edge counts
- Node type distribution
- Average confidence scores

**Use cases**:
- Check which graphs exist
- Verify graph is populated
- Find graphs with most content

---

### /knowledge-search

**Purpose**: Search across knowledge graphs with filters

**Usage**:
```python
from triads.km.graph_access import search_knowledge

# Basic search
print(search_knowledge("OAuth"))

# With filters
print(search_knowledge(
    "auth",
    triad="design",
    node_type="Decision",
    min_confidence=0.85
))
```

**Search algorithm**:
1. Load graphs (filtered by triad if specified)
2. For each node, apply filters (type, confidence)
3. Search in label, description, and ID fields
4. Calculate relevance score (label > description > id)
5. Sort by relevance, then confidence

**Output**:
- Results grouped by triad
- Match snippets with context
- Metadata (type, confidence, matched field)

**Use cases**:
- Find nodes related to a topic
- Discover decisions (ADRs)
- Locate high-confidence findings
- Search by partial node ID

---

### /knowledge-show

**Purpose**: Display detailed information about a specific node

**Usage**:
```python
from triads.km.graph_access import show_node

# Search all triads
print(show_node("auth_decision"))

# Search specific triad
print(show_node("auth_decision", triad="design"))
```

**Output**:
- All node attributes
- Incoming and outgoing edges
- Additional properties (JSON formatted)
- Metadata (created_by, timestamps)

**Use cases**:
- Inspect node details
- Follow relationships
- Check evidence and confidence
- Explore graph structure

---

### /knowledge-help

**Purpose**: Display command reference and examples

**Usage**:
```python
from triads.km.graph_access import get_help
print(get_help())
```

**Output**:
- Command syntax and parameters
- Examples for common tasks
- Troubleshooting guide
- Tips and best practices

---

## Security

### Path Traversal Prevention

Triad names are validated with strict regex: `^[a-zA-Z0-9_-]+$`

This prevents:
- Directory traversal (`../etc/passwd`)
- Hidden files (`.ssh/id_rsa`)
- Special characters that could cause issues

### Safe JSON Parsing

- All JSON parsing wrapped in try/except
- Corrupted files return None (graceful degradation)
- No eval() or exec() - all data treated as plain text

### Path Resolution

```python
# Verify resolved path is under graphs directory
resolved = graph_file.resolve()
graphs_resolved = self._graphs_dir.resolve()
if not str(resolved).startswith(str(graphs_resolved)):
    return None  # Path traversal detected
```

---

## Performance

### Caching Strategy

- **Per-session caching**: Graphs loaded once per Claude Code session
- **Lazy loading**: Only load when first accessed
- **Memory efficient**: Graphs stay in memory (typical: 10-100 nodes = ~50KB each)

### Search Performance

- **Target**: < 100ms for typical graphs (10-100 nodes)
- **Actual**: ~10-30ms on typical hardware
- **Scales linearly**: O(n) where n = total nodes across searched graphs

### Optimization Opportunities

Future improvements could include:
- Index building for faster searches
- Full-text search with ranking
- Graph traversal utilities
- Query caching

---

## Graph Format

Knowledge graphs use NetworkX JSON format:

```json
{
  "directed": true,
  "multigraph": false,
  "graph": {},
  "nodes": [
    {
      "id": "node_id",
      "label": "Human Label",
      "type": "Entity|Concept|Decision|Finding|Uncertainty",
      "description": "Detailed description",
      "confidence": 0.95,
      "evidence": "Supporting evidence",
      "created_by": "agent-name",
      "created_at": "ISO-8601 timestamp",
      ...
    }
  ],
  "links": [
    {
      "source": "node1_id",
      "target": "node2_id",
      "key": "relationship_type"
    }
  ]
}
```

### Node Types

- **Entity**: Concrete things (libraries, tools, systems, files)
- **Concept**: Abstract ideas or principles
- **Decision**: Architectural or design decisions (ADRs)
- **Finding**: Research results or discoveries
- **Uncertainty**: Known unknowns requiring investigation

### Relationship Types

Common relationship types (in `key` field):
- `informs`: Node provides information to target
- `implements`: Implementation of a decision/concept
- `depends_on`: Dependency relationship
- `relates_to`: General relationship
- `produces`: Output relationship
- `requires`: Requirement relationship

---

## Error Handling

### Graceful Degradation

All errors return user-friendly messages with suggestions:

```python
# Graph not found
"Graph 'foo' not found. Available graphs: design, implementation, ..."

# Node not found
"Node 'xyz' not found. Use /knowledge-search xyz to search"

# Ambiguous node
"Node 'test' found in: default, test. Please specify triad."
```

### Exception Types

```python
class InvalidTriadNameError(Exception):
    """Triad name contains invalid characters"""

class GraphNotFoundError(Exception):
    """Requested graph doesn't exist"""

class AmbiguousNodeError(Exception):
    """Node ID exists in multiple triads"""
```

---

## Examples

### Workflow 1: Exploring a New Codebase

```python
# 1. See what graphs exist
print(get_status())

# 2. Check design graph
print(get_status('design'))

# 3. Find architectural decisions
print(search_knowledge("", triad="design", node_type="Decision"))

# 4. View specific decision
print(show_node("auth_decision", triad="design"))
```

### Workflow 2: Verifying Knowledge Quality

```python
# 1. Find low-confidence nodes
print(search_knowledge("", min_confidence=0.0))

# 2. Check nodes needing evidence
print(search_knowledge("missing evidence"))

# 3. View node details to assess quality
print(show_node("questionable_node"))
```

### Workflow 3: Following Relationships

```python
# 1. Start with a known node
details = show_node("oauth2_research")

# 2. Note relationships in output (e.g., "informs â†’ auth_decision")

# 3. Explore related nodes
print(show_node("auth_decision"))

# 4. Continue following the graph
```

---

## Testing

### Manual Testing

The implementation was manually tested with:
- Valid and invalid triad names (path traversal attempts)
- Empty and populated graphs
- Ambiguous node IDs (multiple triads)
- All search filters (triad, type, confidence)
- Nodes with and without relationships
- Corrupted JSON files (graceful handling)

### Test Cases

```python
# Security: Path traversal rejected
get_status("../etc/passwd")
# Returns: "Invalid triad name..."

# Error handling: Nonexistent graph
get_status("nonexistent")
# Returns: "Graph 'nonexistent' not found. Available: ..."

# Search: No results
search_knowledge("xyznonexistent")
# Returns: "No results found for: 'xyznonexistent'. Suggestions: ..."

# Ambiguous nodes: Multiple triads
show_node("constitutional_focus")
# Returns: "Ambiguous node ID... Found in: default, generator"
```

---

## Future Enhancements

### Phase 2 Features (not implemented in MVP)

1. **Advanced Search**
   - Regex pattern matching
   - Multiple query terms (AND/OR logic)
   - Wildcard support

2. **Graph Traversal**
   - Path finding between nodes
   - Subgraph extraction
   - Relationship filtering

3. **Visualization**
   - HTML graph viewer (planned separately)
   - ASCII graph rendering
   - Export to DOT format

4. **Analytics**
   - Node centrality metrics
   - Graph health scores
   - Coverage reports

### Performance Improvements

1. **Indexing**
   - Build search index on first load
   - Faster lookups for large graphs

2. **Incremental Updates**
   - Watch for file changes
   - Reload only modified graphs

3. **Query Optimization**
   - Cache frequent searches
   - Pre-compute statistics

---

## Integration

### With Triad Agents

Agents update graphs using `[GRAPH_UPDATE]` blocks:

```markdown
[GRAPH_UPDATE]
type: add_node
node_id: implementation_cli_commands
node_type: Entity
label: Knowledge Access CLI Commands
description: Implemented 4 CLI commands for browsing graphs
confidence: 1.0
file_path: src/triads/km/graph_access.py
...
[/GRAPH_UPDATE]
```

These updates are processed by hooks (e.g., `on_stop.py`) and written to graph files.

### With Claude Code

Commands can be invoked:
1. **Directly in Python** (from agent scripts)
2. **Via custom commands** (if Claude Code supports)
3. **In documentation** (as executable examples)

---

## Maintenance

### Adding New Commands

To add a new command:

1. Add function to `graph_access.py`
2. Add formatter method (if needed)
3. Create command file in `.claude/commands/`
4. Update help text
5. Test thoroughly
6. Document in this file

### Modifying Graph Format

If graph format changes:
1. Update `GraphLoader.load_graph()` parsing
2. Update `GraphFormatter` methods
3. Update documentation
4. Consider backward compatibility

---

## Troubleshooting

### Import Errors

```python
ModuleNotFoundError: No module named 'triads'
```

**Solution**: Set PYTHONPATH:
```bash
export PYTHONPATH=/path/to/triads/src
python3 -c "from triads.km.graph_access import get_status; print(get_status())"
```

### Empty Graphs

```
Graph 'design' not found
```

**Causes**:
- Graph file doesn't exist yet (no agent has run)
- Filename incorrect (must be `{triad}_graph.json`)
- File is corrupted (check JSON validity)

**Solution**: Check `.claude/graphs/` directory:
```bash
ls -la .claude/graphs/
```

### Slow Search

If search is slow (>1s):
- Graph may be very large (>1000 nodes)
- Consider adding triad filter to limit scope
- Check for file I/O issues (network drive, etc.)

---

## Related Documentation

- **Knowledge Management Principles**: `docs/KM_PRINCIPLES.md`
- **Knowledge Issue Detection**: `docs/km-detection.md`
- **Graph Architecture**: Design phase ADRs
- **Claude Code Integration**: `docs/CLAUDE_CODE_INTEGRATION_GUIDE.md`

---

## Credits

- **Design**: Design Bridge (ADR-001 through ADR-005)
- **Implementation**: Senior Developer (this implementation)
- **Testing**: Manual testing during implementation
- **Documentation**: This document

**Version**: 1.0.0
**Created**: 2025-10-16
**Status**: Complete (MVP)
